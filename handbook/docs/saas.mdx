---
id: saas
title: 10. SaaS 多租户
sidebar_label: 10. SaaS 多租户
---

import useBaseUrl from "@docusaurus/useBaseUrl";

## 10.1 什么是 `SaaS`

> SaaS 是 Software-as-a-Service（软件即服务）的简称，随着互联网技术的发展和应用软件的成熟， 在 21 世纪开始兴起的一种完全创新的软件应用模式。它与“on-demand software”，the application service provider(ASP，应用服务提供商)，hosted software(托管软件)所具有相似的含义。
>
> 它是一种通过 Internet 提供软件的模式，厂商将应用软件统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务。用户不用再购买软件，而改用向提供商租用基于 Web 的软件，来管理企业经营活动，且无需对软件进行维护，服务提供商会全权管理和维护软件，软件厂商在向客户提供互联网应用的同时，也提供软件的离线操作和本地数据存储，让用户随时随地都可以使用其定购的软件和服务。
>
> 对于许多小型企业来说，SaaS 是采用先进技术的最好途径，它消除了企业购买、构建和维护基础设施和应用程序的需要。

## 10.2 什么是多租户

多租户技术或称多重租赁技术，简称 `SaaS`，是一种软件架构技术，是实现如何在多用户环境下（此处的多用户一般是面向企业用户）共用相同的系统或程序组件，并且可确保各用户间数据的隔离性。

**简单讲：在一台服务器上运行单个应用实例，它为多个租户（客户）提供服务。**从定义中我们可以理解：多租户是一种架构，目的是为了让多用户环境下使用同一套程序，且保证用户间数据隔离。那么重点就很浅显易懂了，多租户的重点就是同一套程序下实现多用户数据的隔离。

## 10.3 实现多租户方案

### 10.3.1 独立数据库

这是第一种方案，即一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本较高。

- **优点：**
  为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；如果出现故障，恢复数据比较简单。

- **缺点：**
  增多了数据库的安装数量，随之带来维护成本和购置成本的增加。 这种方案与传统的一个客户、一套数据、一套部署类似，差别只在于软件统一部署在运营商那里。如果面对的是银行、医院等需要非常高数据隔离级别的租户，可以选择这种模式，提高租用的定价。如果定价较低，产品走低价路线，这种方案一般对运营商来说是无法承受的。

### 10.3.2 共享数据库，独立 `Schema`

这是第二种方案，即多个或所有租户共享 `Database`，但是每个租户一个 `Schema`（也可叫做一个 user）。底层库比如是：`SqlServer`、`Oracle` 等，一个数据库下可以有多个 `Schema`。

- **优点：**
  为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可支持更多的租户数量。

- **缺点：**
  如果出现故障，数据恢复比较困难，因为恢复数据库将牵涉到其他租户的数据； 如果需要跨租户统计数据，存在一定困难。

### 10.3.3 共享数据库，共享 `Schema`

共享数据表 这是第三种方案，即租户共享同一个 `Database`、同一个 `Schema`，但在表中增加 **`TenantId`** 多租户的数据字段。这是共享程度最高、隔离级别最低的模式。 即每插入一条数据时都需要有一个客户的标识。这样才能在同一张表中区分出不同客户的数据。

- **优点：**
  三种方案比较，第三种方案的维护和购置成本最低，允许每个数据库支持的租户数量最多。

- **缺点：**
  隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量； 数据备份和恢复最困难，需要逐表逐条备份和还原。

## 10.4 多租户使用方案

`Fur` 框架支持以上三种多租户实现方案，使用简单且容易维护。下面分别使用三种不同方式演示多租户方案用法。

## 10.5 基于 `TenantId` 的方式

此方式在中小型企业系统中最为常用，维护成本低，购置成本低。

### 10.5.1 创建租户数据库上下文

```cs {6-7} title="Fur.EntityFramework.Core\DbContexts\MultiTenantDbContext.cs"
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;

namespace Fur.EntityFramework.Core
{
    [AppDbContext("Sqlite3ConnectionString")]
    public class MultiTenantDbContext : AppDbContext<MultiTenantDbContext, MultiTenantDbContextLocator>
    {
        public MultiTenantDbContext(DbContextOptions<MultiTenantDbContext> options) : base(options)
        {
        }
    }
}
```

:::important 特别注意

多租户操作建议单独一个数据库上下文，而且需指定 `MultiTenantDbContextLocator` 数据库上下文定位器。

:::

### 10.5.2 注册多租户数据库上下文

```cs {14}
using Fur.DatabaseAccessor;
using Microsoft.Extensions.DependencyInjection;

namespace Fur.EntityFramework.Core
{
    [AppStartup(600)]
    public sealed class FurEntityFrameworkCoreStartup : AppStartup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddDatabaseAccessor(options =>
            {
                options.AddDbPool<FurDbContext>(DbProvider.Sqlite);
                options.AddDbPool<MultiTenantDbContext, MultiTenantDbContextLocator>(DbProvider.Sqlite);
            });
        }
    }
}
```

### 10.5.3 添加 `Tenant` 种子数据

```cs {8,12-28} title="Fur.EntityFramework.Core\SeedDatas\TenantSeedData.cs"
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;

namespace Fur.EntityFramework.Core
{
    public class TenantSeedData : IEntitySeedData<Tenant, MultiTenantDbContextLocator>
    {
        public IEnumerable<Tenant> HasData(DbContext dbContext, Type dbContextLocator)
        {
            return new List<Tenant>
            {
                new Tenant
                {
                    TenantId=Guid.Parse("383AFB88-F519-FFF8-B364-6D563BF3687F"),
                    Name="默认租户",
                    Host="localhost:44313",
                    CreatedTime=DateTime.Parse("2020-10-06 20:19:07")
                },
                new Tenant
                {
                    TenantId=Guid.Parse("C5798CB6-16D6-0F42-EB56-59C695353BC0"),
                    Name="其他租户",
                    Host="localhost:5000",
                    CreatedTime=DateTime.Parse("2020-10-06 20:20:32")
                }
            };
        }
    }
}
```

:::note 特别说明

该步骤只在 `Code First` 方式执行，`Database First` 无需配置种子数据。

:::

### 10.5.4 根据模型创建 `Tenant` 表

```shell
Add-Migration add_tenant_table -Context MultiTenantDbContext
```

```shell
Update-Database -Context MultiTenantDbContext
```

### 10.5.5 实现 `IMultiTenantOnTable` 接口

在需要多租户的数据库上下文中实现 `IMultiTenantOnTable` 接口，如：

```cs {8,14-17}
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;
using System;

namespace Fur.EntityFramework.Core
{
    [AppDbContext("Sqlite3ConnectionString")]
    public class FurDbContext : AppDbContext<FurDbContext>, IMultiTenantOnTable, IModelBuilderFilter
    {
        public FurDbContext(DbContextOptions<FurDbContext> options) : base(options)
        {
        }

        public Guid? GetTenantId()
        {
            return base.Tenant.TenantId;
        }
    }
}
```

在 `GetTenantId()` 方法中，首先获取请求的 `主机地址`，然后根据主机地址查询对应的租户 `TenantIdId`，避免多次查询数据库，这里使用了 `IMemoryCache` 内存缓存。

### 10.5.6 实现 `IModelBuilderFilter` 接口

`IModelBuilderFilter` 接口是全局查询过滤器实现接口，所以我们需要配置实体 `TenantId` 过滤器

```cs {9,20-23}
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using System;

namespace Fur.EntityFramework.Core
{
    [AppDbContext("Sqlite3ConnectionString")]
    public class FurDbContext : AppDbContext<FurDbContext>, IMultiTenantOnTable, IModelBuilderFilter
    {
        public FurDbContext(DbContextOptions<FurDbContext> options) : base(options)
        {
        }

        public Guid? GetTenantId()
        {
            return base.Tenant.TenantId;
        }

        public void OnCreating(ModelBuilder modelBuilder, EntityTypeBuilder entityBuilder, DbContext dbContext, Type dbContextLocator)
        {
            entityBuilder.HasQueryFilter(TenantIdQueryFilterExpression(entityBuilder, GetTenantId().Value));
        }
    }
}
```

### 10.5.7 重写 `SavingChangesEvent` 事件方法

通过上面的步骤，我们已经解决了 `查询` 租户过滤功能，但是 `新增` 和 `更新` 还未处理。

- `新增` 数据的时候自动设置 `TenantId` 的值
- `更新` 数据的时候排除 `TenantId` 属性更新

实现上面的步骤很简单，只需要重写 `SavingChangesEvent` 事件方法即可。

```cs {26-48}
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using System;
using System.Linq;

namespace Fur.EntityFramework.Core
{
    [AppDbContext("Sqlite3ConnectionString")]
    public class FurDbContext : AppDbContext<FurDbContext>, IMultiTenantOnTable, IModelBuilderFilter
    {
        public FurDbContext(DbContextOptions<FurDbContext> options) : base(options)
        {
        }

        public Guid? GetTenantId()
        {
            return base.Tenant.TenantId;
        }

        public void OnCreating(ModelBuilder modelBuilder, EntityTypeBuilder entityBuilder, DbContext dbContext, Type dbContextLocator)
        {
            entityBuilder.HasQueryFilter(TenantIdQueryFilterExpression(entityBuilder, GetTenantId().Value));
        }

        protected override void SavingChangesEvent(object sender, SavingChangesEventArgs e)
        {
            // 获取当前事件对应上下文
            var dbContext = sender as FurDbContext;

            // 获取所有新增和更新的实体
            var entities = dbContext.ChangeTracker.Entries().Where(u => u.State == EntityState.Added || u.State == EntityState.Modified);

            foreach (var entity in entities)
            {
                switch (entity.State)
                {
                    // 自动设置租户Id
                    case EntityState.Added:
                        entity.Property(nameof(Entity.TenantId)).CurrentValue = base.TenantId;
                        break;
                    // 排除租户Id
                    case EntityState.Modified:
                        entity.Property(nameof(Entity.TenantId)).IsModified = false;
                        break;
                }
            }
        }
    }
}
```

<img src={useBaseUrl("img/saas1.png")} />

## 10.6 基于 `Database` 的方式

此方式在中大型企业系统中最为常用，一个租户（客户）一个独立的数据库。

### 10.6.1 创建租户数据库上下文

```cs {6-7} title="Fur.EntityFramework.Core\DbContexts\MultiTenantDbContext.cs"
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;

namespace Fur.EntityFramework.Core
{
    [AppDbContext("Sqlite3ConnectionString")]
    public class MultiTenantDbContext : AppDbContext<MultiTenantDbContext, MultiTenantDbContextLocator>
    {
        public MultiTenantDbContext(DbContextOptions<MultiTenantDbContext> options) : base(options)
        {
        }
    }
}
```

:::important 特别注意

多租户操作建议单独一个数据库上下文，而且需指定 `MultiTenantDbContextLocator` 数据库上下文定位器。

:::

### 10.6.2 注册多租户数据库上下文

```cs {13,14}
using Fur.DatabaseAccessor;
using Microsoft.Extensions.DependencyInjection;

namespace Fur.EntityFramework.Core
{
    [AppStartup(600)]
    public sealed class FurEntityFrameworkCoreStartup : AppStartup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddDatabaseAccessor(options =>
            {
                options.AddDb<FurDbContext>(DbProvider.Sqlite);
                options.AddDbPool<MultiTenantDbContext, MultiTenantDbContextLocator>(DbProvider.Sqlite);
            });
        }
    }
}
```

:::caution 特别注意

需要 `Database` 多租户方案的数据库上下文需要采用 `AddDb` 注册，而不是 `AddDbPool`。原因是 `AddDbPool` 方式注册后续不支持 `OnConfiguring` 重写！！！

:::

### 10.6.3 添加 `Tenant` 种子数据

```cs {8,12-30} title="Fur.EntityFramework.Core\SeedDatas\TenantSeedData.cs"
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;

namespace Fur.EntityFramework.Core
{
    public class TenantSeedData : IEntitySeedData<Tenant, MultiTenantDbContextLocator>
    {
        public IEnumerable<Tenant> HasData(DbContext dbContext, Type dbContextLocator)
        {
            return new List<Tenant>
            {
                new Tenant
                {
                    TenantId=Guid.Parse("383AFB88-F519-FFF8-B364-6D563BF3687F"),
                    Name="默认租户",
                    Host="localhost:44313",
                    CreatedTime=DateTime.Parse("2020-10-06 20:19:07"),
                    ConnectionString="Data Source=./Fur.db" // 配置连接字符串
                },
                new Tenant
                {
                    TenantId=Guid.Parse("C5798CB6-16D6-0F42-EB56-59C695353BC0"),
                    Name="其他租户",
                    Host="localhost:5000",
                    CreatedTime=DateTime.Parse("2020-10-06 20:20:32"),
                    ConnectionString="Data Source=./Fur2.db" // 配置连接字符串
                }
            };
        }
    }
}
```

:::note 特别说明

该步骤只在 `Code First` 方式执行，`Database First` 无需配置种子数据。

:::

### 10.6.4 根据模型创建 `Tenant` 表

```shell
Add-Migration add_tenant_table -Context MultiTenantDbContext
```

```shell
Update-Database -Context MultiTenantDbContext
```

### 10.6.5 实现 `IMultiTenantOnDatabase` 接口

在需要多租户的数据库上下文中实现 `IMultiTenantOnDatabase` 接口，如：

```cs {6,12-15}
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;

namespace Fur.EntityFramework.Core
{
    public class FurDbContext : AppDbContext<FurDbContext>, IMultiTenantOnDatabase
    {
        public FurDbContext(DbContextOptions<FurDbContext> options) : base(options)
        {
        }

        public string GetDatabaseConnectionString()
        {
            return base.Tenant.ConnectionString;
        }
    }
}
```

### 10.6.6 重写 `OnConfiguring` 方法

在需要多租户的数据库上下文中重写 `OnConfiguring` 方法并配置连接字符串：

```cs {12-17}
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;

namespace Fur.EntityFramework.Core
{
    public class FurDbContext : AppDbContext<FurDbContext>, IMultiTenantOnDatabase
    {
        public FurDbContext(DbContextOptions<FurDbContext> options) : base(options)
        {
        }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite(GetDatabaseConnectionString());

            base.OnConfiguring(optionsBuilder);
        }

        public string GetDatabaseConnectionString()
        {
            return base.Tenant.ConnectionString;
        }
    }
}
```

<img src={useBaseUrl("img/saas2.png")} />

## 10.7 基于 `Schema` 的方式

此方式在中小型企业系统中也不少见，一个租户（客户）共享数据库且不同 `Schema`。

### 10.7.1 创建租户数据库上下文

```cs {6-7} title="Fur.EntityFramework.Core\DbContexts\MultiTenantDbContext.cs"
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;

namespace Fur.EntityFramework.Core
{
    [AppDbContext("Sqlite3ConnectionString")]
    public class MultiTenantDbContext : AppDbContext<MultiTenantDbContext, MultiTenantDbContextLocator>
    {
        public MultiTenantDbContext(DbContextOptions<MultiTenantDbContext> options) : base(options)
        {
        }
    }
}
```

:::important 特别注意

多租户操作建议单独一个数据库上下文，而且需指定 `MultiTenantDbContextLocator` 数据库上下文定位器。

:::

### 10.7.2 注册多租户数据库上下文

```cs {14}
using Fur.DatabaseAccessor;
using Microsoft.Extensions.DependencyInjection;

namespace Fur.EntityFramework.Core
{
    [AppStartup(600)]
    public sealed class FurEntityFrameworkCoreStartup : AppStartup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddDatabaseAccessor(options =>
            {
                options.AddDbPool<FurDbContext>(DbProvider.Sqlite);
                options.AddDbPool<MultiTenantDbContext, MultiTenantDbContextLocator>(DbProvider.Sqlite);
            });
        }
    }
}
```

### 10.7.3 添加 `Tenant` 种子数据

```cs {8,12-30} title="Fur.EntityFramework.Core\SeedDatas\TenantSeedData.cs"
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;

namespace Fur.EntityFramework.Core
{
    public class TenantSeedData : IEntitySeedData<Tenant, MultiTenantDbContextLocator>
    {
        public IEnumerable<Tenant> HasData(DbContext dbContext, Type dbContextLocator)
        {
            return new List<Tenant>
            {
                new Tenant
                {
                    TenantId=Guid.Parse("383AFB88-F519-FFF8-B364-6D563BF3687F"),
                    Name="默认租户",
                    Host="localhost:44313",
                    CreatedTime=DateTime.Parse("2020-10-06 20:19:07"),
                    Schema="dbo" // Schema
                },
                new Tenant
                {
                    TenantId=Guid.Parse("C5798CB6-16D6-0F42-EB56-59C695353BC0"),
                    Name="其他租户",
                    Host="localhost:5000",
                    CreatedTime=DateTime.Parse("2020-10-06 20:20:32"),
                    Schema="fur" // Schema
                }
            };
        }
    }
}
```

:::note 特别说明

该步骤只在 `Code First` 方式执行，`Database First` 无需配置种子数据。

:::

### 10.7.4 根据模型创建 `Tenant` 表

```shell
Add-Migration add_tenant_table -Context MultiTenantDbContext
```

```shell
Update-Database -Context MultiTenantDbContext
```

### 10.7.5 实现 `IMultiTenantOnSchema` 接口

在需要多租户的数据库上下文中实现 `IMultiTenantOnSchema` 接口，如：

```cs {6,12-15}
using Fur.DatabaseAccessor;
using Microsoft.EntityFrameworkCore;

namespace Fur.EntityFramework.Core
{
    [AppDbContext("Sqlite3ConnectionString")]
    public class FurDbContext : AppDbContext<FurDbContext>, IMultiTenantOnSchema
    {
        public FurDbContext(DbContextOptions<FurDbContext> options) : base(options)
        {
        }

        public string GetSchemaName()
        {
            return base.Tenant.Schema;
        }
    }
}
```

### 10.7.6 关于 `Code First 数据迁移`

基于 `Schema` 方式比较特别，生成数据迁移的时候没办法获取租户信息，所以建议**分开多次迁移**，如：

```cs
public string GetSchemaName()
{
    return base.Tenant.Schema?? "租户一Schema";
}
```

```cs
public string GetSchemaName()
{
    return base.Tenant.Schema?? "租户二Schema";
}
```

这样就可以在迁移的时候生成多次迁移了。

## 10.8 反馈与建议

:::note 与我们交流

给 Fur 提 [Issue](https://gitee.com/monksoul/Fur/issues/new?issue)。
